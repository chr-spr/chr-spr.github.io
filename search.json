[{"title":"Markdown语法","date":"2022-02-18T14:29:34.000Z","url":"/2022/02/18/Python%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%88%9D%E7%BA%A7%E4%B8%B2%E8%AE%B2%E8%AE%B2%E4%B9%89/","categories":[["undefined",""]],"content":"1+x Python程序开发（初级）一、 证书相关知识点1.1 考试级别Python开发职业技能分为初、中、高三个等级 1.2 考核方式与题型考核方式为闭卷考试，采用上机考试形式。考试包括理论考试和实操考试两部分。理论考试时长90分钟，试卷满分100分，共50道试题，其中单选题30道，多选题10道，判断题10道；实操考试时长150分钟，试卷满分100分，试卷含5道实践性试题，试题形式包括案例分析、软件代码编码或是网页效果呈现等。 1.3 合格标准理论考试试卷满分为100分，权重40%;实操考试试卷满分为100分，权重60%。综合成绩等于理论和实操考试成绩的加权之和，综合成绩合格标准为大于等于60分，综合成绩合格的学员可以获得相应级别的职业技能等级证书。 1.4 考试计算机环境配置1.4.1 硬件CPU：四核以上，主频2. 0GHz以上 内存：4GB 硬盘：50G空闲 网卡：1000M 1.4.2 软件操作系统：Window10 开发工具：PyCharm2019以上 输入法要求：安装英文、拼音、五笔输入。 浏览器要求：谷歌稳定版75.0以上版本 1.5 考试内容、题型及分值（1）理论：（单选题（60分））、（多选题10到（20分））、（判断题（20分）） （2）实操：程序填空（5个左右项目） 1.6 初级证书涵盖的主要知识点 二、Python基础2.1. Python的发展史2.1.1 起源Python的创始人为吉多·范罗苏姆（Guido von Rossum）当时他在阿姆斯特丹的荷兰数学和计算机科学研究学会工作。当时，他在工作中接触了多种语言，Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。尽管ABC语言很特别，但学习难度 也很大。 传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编 译器。 这样，ABC语言就很难快速传播。 1989年的圣诞节期间吉多·范罗苏姆为了在打发时间，决心开发一个新的脚本解释编程，作为ABC语言的一种继承，他希望这个新的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。之所以选中Python作为编程的名字，是因为他是BBC电视剧——《蒙提·派森的飞行马戏团》（Monty Python’s Flying Circus）的爱好者。 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程 序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。 Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言 2.1.2 Python常识 Python的发音与拼写 （英&#x2F;ˈpaɪθən&#x2F;，美&#x2F;ˈpaɪθɑːn&#x2F; ） Python的意思是蟒蛇，源于作者喜欢的一部电视剧 Python的作者是Guido van Rossum（龟叔） Python是龟叔在1989年圣诞节期间，为了打发无聊的圣诞节而用C编写的一个编程语言 Python正式诞生于1991年 Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译） Python目前有两个版本，Python2和Python3，最新版分别为2.7.18和3.10.0，Python2在2020年官方已停止维护，现阶段大部分公司用的是Python3，无需再学习Python2 Life is shot, you need Python. 人生苦短，我用Python 2021年8月份，编程语言流行排行榜 2.2 第一个Python程序2.2.1 hello world 打开终端，进入Python交互环境，输入以下代码 使用编辑器将代码保存为hello.py，然后使用以下命令运行 2.3 注释2.3.1 单行注释 2.3.2多行注释 2.4 变量及类型2.4.1 变量的定义 说明：变量的名字只能由数字、字母、下划线组成，并且数字不能在开头（中文可以，但不要使用）变量名推荐使用单词全小写，单词和单词之间使用下划线进行连接 可以使用id函数查看变量的内存地址 2.4.2 变量的类型可以使用Type函数来查看变量的类型 2.5 输入和输出2.5.1 输入 2.5.2 输出 2.6 运算符2.6.1算数运算符 运算符 含义 描述 + 加 两个对象相加 - 减 得到负数或是一个数减去另一个数 * 乘 两个数相乘或是返回一个被重复若干次的字符串 &#x2F; 除 两数相除 &#x2F;&#x2F; 取整除 返回商的整数部分。如 9&#x2F;&#x2F;2 输出结果 4 , 9.0&#x2F;&#x2F;2.0 输出结果 4.0 % 取余 返回除法的余数 ** 幂 幂运算。x**y 返回x的y次幂 运算符的优先级 2.6.2 赋值运算符 运算符 描述 实例 &#x3D; 赋值运算符 把&#x3D;号右边的结果给左边的变量 num&#x3D;1+2*3 结果num的值为7 2.6.3 复合赋值运算符 运算符 描述 实例 +&#x3D; 加法赋值运算符 c +&#x3D; a 等效于 c &#x3D; c + a -&#x3D; 减法赋值运算符 c -&#x3D; a 等效于 c &#x3D; c - a *&#x3D; 乘法赋值运算符 c *&#x3D; a 等效于 c &#x3D; c * a &#x2F;&#x3D; 除法赋值运算符 c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a %&#x3D; 取模赋值运算符 c %&#x3D; a 等效于 c &#x3D; c % a **&#x3D; 幂赋值运算符 c **&#x3D; a 等效于 c &#x3D; c ** a &#x2F;&#x2F;&#x3D; 取整除赋值运算符 c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a 2.6.4 比较运算符 运算符 描述 示例 &#x3D;&#x3D; 检查两个操作数的值是否相等，如果是则条件变为真。 如a&#x3D;3,b&#x3D;3则（a &#x3D;&#x3D; b) 为 true. !&#x3D; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a&#x3D;1,b&#x3D;3则(a !&#x3D; b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a&#x3D;1,b&#x3D;3则(a &lt;&gt; b) 为 true。这个类似于 !&#x3D; 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a&#x3D;7,b&#x3D;3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a&#x3D;7,b&#x3D;3则(a &lt; b) 为 false. &gt;&#x3D; 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a&#x3D;3,b&#x3D;3则(a &gt;&#x3D; b) 为 true. &lt;&#x3D; 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a&#x3D;3,b&#x3D;3则(a &lt;&#x3D; b) 为 true. 2.6.5 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 2.7 数据类型转换2.7.1 常用的数据类型转换函数 函数 说明 int(x [,base ]) 将x转换为一个整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 2.8 条件判断语句2.8.1 条件语句 条件表达式可以是一个返回布尔值的表达式，也可以是任何可以转换为bool值的数据类型 注：条件语句可以嵌套 2.9 循环语句2.9.1 while循环 示例：求1~100的整数和 自己动手：计算0~100之间的偶数和 注：while循环可以嵌套使用 2.9.2 for循环 在Python中 for循环可以遍历任何序列，如一个列表或者一个字符串等。 2.9.3 break和continue break 结束整个循环 continue：结束本次循环，开始下一次循环 注意： break和continue只能用在循环结构中，不能单独使用 break&#x2F;continue在嵌套循环中，只对最近的一层循环起作用 三、Python数据类型3.1 字符串3.1.1 字符串的定义双引号或者单引号中的数据，就是字符串 3.1.2 字符串的输出 3.1.3 字符串的输入 3.1.4 下标和切片 下标 所谓“下标”，就是编号，我们可以通过下标来获取字符串中的某个字符 切片 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：**[起始:结束:步长]** 注意：选取的区间属于左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。 自己动手：给一个字符串string，请反转字符串 3.1.5 字符串常用方法 find 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1 index 跟find()方法一样，只不过如果str不在 mystr中会报一个异常 count 返回 str在start和end之间 在 mystr里面出现的次数 replace 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次 split 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 次 lower 转换 mystr 中所有大写字符为小写 upper 转换 mystr 中的小写字母为大写 center 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 strip isalpha 如果 mystr 所有字符都是字母 则返回 True,否则返回 False isdigit 如果 mystr 只包含数字则返回 True 否则返回 False isalnum 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False join mystr 中每个字符后面插入|,构造出一个新的字符串 3.1.6 字符串格式化 %格式化 转换说明符 解释 %d、%i 转换为带符号的十进制整数 %o 转换为带符号的八进制整数 %x、%X 转换为带符号的十六进制整数 %e 转化为科学计数法表示的浮点数（e 小写） %E 转化为科学计数法表示的浮点数（E 大写） %f、%F 转化为十进制浮点数 %g 智能选择使用 %f 或 %e 格式 %G 智能选择使用 %F 或 %E 格式 %c 格式化字符及其 ASCII 码 %r 使用 repr() 函数将表达式转换为字符串 %s 使用 str() 函数将表达式转换为字符串 （1）整数的输出 %o：oct 八进制 %d：dec 十进制 %x：hex 十六进制 （2）浮点数输出 %f：保留小数点后面六位有效数字。 如：%.3f，保留3位小数位 %e：保留小数点后面六位有效数字，指数形式输出 如：%.3e，保留3位小数位，使用科学计数法。 %g：在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法 如：%.3g，保留3位有效数字，使用小数或科学计数法。 （3）字符串输出 %10s：右对齐，占位符10位 %-10s：左对齐，占位符10位 %.2s：截取2位字符串 %10.2s：10位占位符，截取两位字符串 **2.format 格式化 ** 相对基本格式化输出采用‘%’的方法，format()功能更强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号‘{}’作为特殊字符代替‘%’，在开发过程中推荐使用此方式进行字符串格式化。 3.f-Strings 格式化 f-strings是Python3.6开始加入标准库的格式化输出新的写法，这个格式化输出比之前的%s或者format效率高并且更加简化，更加好用。 3.2 列表3.2.1 定义列表和遍历列表 列表的定义 可以使用range函数快速生成列表 使用for循环遍历列表 使用while循环遍历 3.2.2 列表的常用方法 append 可以向列表中添加元素 extend 通过列表扩展列表 insert 指定位置插入元素 修改元素 修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 查找元素 &lt;1&gt; in和not in：查看元素是否存在列表中 &lt;2&gt; index：查找元素在列表中的位置 &lt;3&gt; count：统计元素在列表中出现的次数 我们可以使用in来测试一个对象是否是可迭代的对象 删除元素 &lt;1&gt; del：根据下标进行删除 &lt;2&gt; pop：弹出最后一个元素 &lt;3&gt;remove: 根据元素的值删除 元素排序（sort、reverse方法和reversed函数） sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse&#x3D;True可改为倒序，由大到小。 reverse方法是将list逆置。 reversed函数用来排序 count：统计元素在列表中出现的次数 注：列表可进行嵌套使用 3.3 元组3.3.1 元组的定义Python的元组与列表类似，不同之处在于元组的元素不能修改。元组通常使用小括号，列表使用方括号。 注意： a &#x3D; (1)， 此时a并不是一个元组 3.3.2 元组常用操作 元素访问 count：统计元素出现的次数 index：查找元素 3.3.3 元组遍历 3.4 字典3.4.1 字典的定义字典是使用键值对存储数据的一种数据类型 3.4.2 字典的常见操作 访问元素值 根据键访问值，在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值 修改元素 字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改 添加元素 如果在使用 变量名[‘键’] &#x3D; 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素 删除元素 &lt;1&gt; del：删除键值对 &lt;2&gt; clear：清空元素 3.4.3 字典常用函数和方法 len函数：测量字典中，键值对的个数 keys方法：获取字典中所有的键 values方法：获取字典中所有的值 items方法：获取字典中所有的键值对 3.4.4 字典的遍历 字典和字符串、列表、元组一样都可以进行遍历 3.5 集合3.5.1 集合的创建集合是一种无序不重复的序列 3.5.2 集合常用方法 add：给集合添加元素 update：把集合 y 中的项目插入集合 x： remove：移除元素 差集- 对称差集^ 交集&amp; 并集| 注：集合也可以使用循环进行遍历 3.6 公共方法3.6.1 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 3.6.2 内置函数 序号 方法 描述 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 四、函数4.1 函数的定义和调用如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数 4.1.1 函数的定义定义函数的格式如下： 示例: 4.1.2 函数的调用定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它 调用函数很简单的，通过 函数名() 即可完成调用 注：函数参数是可选的，函数可以没有参数，函数可以没有返回值，return除了用来返回结果，还可以用来结束函数 4.2 变量的作用域 局部变量 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 全局变量 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量 4.2 递归函数函数自己调用自己就是递归函数 4.3 匿名函数用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： 五、 Python面向对象5.1 面向对象的概念 什么是对象? 对象是拥有具体属性值(名词)和行为（动词）的实体，比如在现实生活中的实际存在的一辆车，一个人，一个苹果等。对象，又称实例，在Python中，一切皆对象，比如我们之前使用的整数、字符串、列表、字典等。 什么是面向对象? 面向对象就是在程序中，把一切都看做对象，基于这些对象来编程。当你要做事情的时候，你不会亲自去做，而是调用些对象去做。 什么是类? 类可以理解为对象的模板，其中定义了同类对象应该具有的属性和方法，类可以用来创建一个或多个同类对象。类是一个抽象的概念，而对象是类具象化的结果。类比于现实世界中的事务，比如汽车就相当于是一个类，提到它我们知道它应具有行驶的功能，而车型、重量、最大行驶速度、车龄等等是汽车应该具有的属性。而一辆具体的汽车是一个对象，在这个对象中，车型、重量等属性有了具体的值。 类的创建语法： 5.2 实例方法语法： 作用： 用于描述一个对象的行为,让此类型的全部对象都拥有相同的行为 说明： 实例方法实质是函数,是定义在类内的函数 。实例方法至少有一个形参,第一个形参代表调用这个方法的实例,一般命名为’self’ 调用： 实例.实例方法名(调用传参) 示例： 创建一个Car类，定义实例方法run 5.3 实例属性每个实例都可以有自己的变量,此变量称为实例变量(也叫实例属性) 实例属性的使用 实例.实例属性名 实例属性的赋值 可以通过”&#x3D;”为实例属性赋值 实例.实例属性名 &#x3D; 值 5.4 初始化方法作用：对新创建的对象进行初始化。 语法： 示例： 为刚才创建的Car类添加初始化方法，添加品牌和颜色属性 5.5 保护对象如果有一个对象，当需要对其属性进行修改属性时，可以通过以下方法来实现： （1）对象名.属性名 &#x3D; 数据 —-&gt;直接修改 （2）对象名.方法名() —-&gt;间接修改 作用 为了更好的保存属性安全，即不能随意修改。 为了更好的保存属性安全，即不能随意修改，一般的处理方式为 （1）将属性定义为私有属性 （2）添加一个可以调用的方法，供调用 示例 5.6 析构方法作用：当一个对象被Python解释器进行垃圾回收时会调用此方法 语法： 示例： 说明： 当对象的引用计数为0是对象会被回收，可以通过sys.getrefcount()来获取对象的引用计数。 5.7 继承类型间可构成继承关系。就像老虎继承自猫科，而猫科又继承自哺乳动物，往上还有更顶层的类型。继承关系让类型拥有其所有祖先类型的特征。因历史原因，Python允许多继承，也就是说可有多个父类型，好似人类同时拥有父族、母族遗传特征。 继承关系图： 语法： 示例： 注意： 私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 python中是可以多继承的 父类中的方法、属性，子类会继承 如果父类中有同名的方法，可以通过对象.__mro__来查看方法搜索的继承顺序 5.8 方法重写作用：如果父类中的方法不满足自身需求可对父类方法进行重写 示例： 5.9 调用父类方法作用：在某种情况下，我们需要在对象的方法内部调用基类的方法。 示例： 5.10 多态多态（英语：polymorphism）指为不同数据类型的实体提供统一的接口。调用这个接口时根据不同的实体有不同的表现形式。 示例： 5.11 类属性和实例属性类属性：用来定义这个类型的所有对象所公有的特征属性 实例属性：用来定义对象所特有的特征属性 示例： 5.12 静态方法和类方法静态方法：如果一个方法和类对象以及实例对象都没有关联关系，只是为了方便把函数放在类中进行代码封装，这个方法就是一个静态方法。 类方法：用来定义这个类型的所有对象所公有的行为。 示例： 5.13 对象的序列化在开发中我们经常需要把Python的数据类型序列化后保存到文件中或数据库里。在前后端分离的Web开发中我们需要把Python的数据类型序列化为json字符串返回给前端使用。我们使用json模块可以很容易将列表字典序列化，但json模块默认是不能序列化对象的，不过它提供了一个接口可以让开发者自定义序列化方法，我们可以使用这个方法来达到序列化对象的目的。 staff.py serialization.py 六、Python高级编程6.1 异常当Python检测到一个错误时，解释器就无法继续执行，出现了一些错误提示，这就是”异常”。我们可以用异常处理来解决这个问题。 6.1.1异常处理示例： 说明：可以使用raise抛出自定义异常。 6.2模块和包6.2.1 模块1.模块：每一个.py文件就是一个模块。 2.模块的导入方法: （1）import （2）from … import （3）from … import * （4）as 3.模块导入的限制： 如果一个文件中有__all__变量，那么也就意味着这个变量中的元素，不会被from … import *时导入。 4.模块中__name__的使用 说明：当导入一个模块时，Python将会去执行被导入模块中的代码。 6.2.2 包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py 文件，那么这个文件夹就称之为包。 作用：有效避免模块名称冲突问题，让应用组织结构更加清晰。 说明：__init__.py 控制着包的导入行为，在__init__.py文件中，定义一个__all__变量，它控制着 from 包名 import *时允许导入的模块。 6.3 文件操作6.3.1 文件读写文件是用来存储数据的，并且可以实现持久化存储。在Python里面是通过文件对象来操作文件。 文件打开函数open() 语法格式 f &#x3D; open(file, mode&#x3D;’r’，encoding&#x3D;None) file：文件路径 mode:读取模式，默认为r encoding:编码方式，windows下默认为gbk 模式 说明 r 读模式，默认模式 w 写模式 a 追加模式 文件操作方法 方法 说明 f.readline() 读取一行数据 f.readlines() 返回每行字符串的列表 f.write() 将字符串写入文件 f.close() 关闭文件 with语句 可以通过with语句处理文件关闭 文件的迭代读取 open函数得到的文件对象是一个可迭代对象，可以用for循环进行遍历 6.3.2 os模块实际开发中，有时需要用程序的方式对文件夹进行一定的操作，比如创建、删除等。 创建文件夹： 递归创建文件夹： 获取当前目录： 获取目录列表： 删除文件夹： 删除文件： 递归删除文件夹： 修改文件名： 递归修改文件夹和文件名： 6.4 装饰器6.4.1 闭包什么是闭包? 闭包 &#x3D; 函数 + 环境变量 6.4.2 闭包使用案例 6.4.3 装饰器为什么要使用装饰器？案例：给一个函数添加一个新功能，每次运行函数打印出该函数的运行时间。 软件开发中的原则： （1）对功能扩展是开放的 （2）对修改是封闭的 缺点：改变了函数的调用方式 装饰器版本： 总结： 什么是装饰器？ 装饰器是Python提供的一个语法糖，它能让我们的代码更简洁、优雅。 为什么要使用装饰器？ 装饰器可以在不改变原来函数中代码内容和代码组织结构的同时给原来的函数增加新功能。 6.5 多任务利用现学知识能够让两个函数或者方法同时执行吗? 不能，因为之前所写的程序都是单任务的，也就是说一个函数或者方法执行完成另外一个函数或者方法才能执行，要想实现这种操作就需要使用多任务。 多任务的最大好处是充分利用CPU资源，提高程序的执行效率。 多任务是指在同一时间内执行多个任务，例如: 现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。 多任务效果图: 多任务执行方式：并发和并行 并发：在一段时间内交替去执行任务。 例如：对于单核cpu处理多任务,操作系统轮流让各个软件交替执行，假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。 并行：对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。 6.5.1 多进程一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。 说明： 一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。 单进程效果图： 多进程效果图： 案例： 获取进程编号：获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。 获取当前进程编号：os.getpid()获取当前父进程编号：os.getppid() 前面我们使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢? Process类执行任务并给任务传参数有两种方式: args 表示以元组的方式给执行任务传参kwargs 表示以字典方式给执行任务传参 总结： 进程是操作系统进行资源分配的基本单位。进程是Python程序中实现多任务的一种方式。进程不共享全局变量。 6.5.2 多线程线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。 多线程效果图： 案例： 说明： 线程是Python程序中实现多任务的另外一种方式，线程的执行需要cpu调度来完成。线程共享全局变量。 全局变量数据错误的解决办法: **线程同步: **保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。 线程同步的方式: （1）线程等待(join)（2）互斥锁：threading模块中定义了Lock变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。 互斥锁使用步骤:1）创建锁mutex &#x3D; threading.Lock() 2）上锁mutex.acquire()这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定… 3）释放锁mutex.release() 6.6 上下文管理器6.6.1 上下文协议with 这个关键字，对于每一学习Python的人，都不会陌生。 操作文本对象的时候，我们都建议使用 with open ，因为它能自动帮助我们关闭文件对象，这就是一个上下文管理的例子。 什么是上下文管理器？ 上下文表达式：with后面的表达式叫上下文表达式， 上下文表达式应该返回一个上下文管理器 上下文管理器：实现了上下文管理协议的类的实例就是一个上下文管理器 上下文管理协议：在一个类里，实现了__enter__和__exit__的方法，就实现了上下文协议 简单点说，就是在一个类里，实现了__enter__和__exit__的方法，这个类的实例就是一个上下文管理器。 我们执行一下，通过日志的打印顺序。可以知道其执行过程。 从这个示例可以很明显的看出，在编写代码时，可以将资源的连接或者获取放在__enter__中，而将资源的关闭写在__exit__ 中。 为什么要用上下文管理器？ 学习时多问自己几个为什么，养成对一些细节的思考，有助于加深对知识点的理解。 为什么要使用上下文管理器？ 在我看来，这和 Python 崇尚的优雅风格有关。 可以以一种更加优雅的方式，操作（创建&#x2F;获取&#x2F;释放）资源，如文件操作、数据库连接； 可以以一种更加优雅的方式，处理异常； 第一种，我们上面已经以资源的连接为例讲过了。 而第二种，会被大多数人所忽略。这里会重点讲一下。 大家都知道，处理异常，通常都是使用 try...execept.. 来捕获处理的。这样做一个不好的地方是，在代码的主逻辑里，会有大量的异常处理代理，这会很大的影响我们的可读性。 好一点的做法呢，可以使用 with 将异常的处理隐藏起来。 仍然是以上面的代码为例，我们将1/0 这个一定会抛出异常的代码写在 operate 里 运行一下，惊奇地发现，居然不会报错。 这就是上下文管理协议的一个强大之处，异常可以在__exit__ 进行捕获并由你自己决定如何处理，是抛出呢还是在这里就解决了。在__exit__ 里返回 True（没有return 就默认为 return False），就相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了。 在 写__exit__ 函数时，需要注意的事，它必须要有这三个参数： exc_type：异常类型 exc_val：异常值 exc_tb：异常的错误栈信息 当主逻辑代码没有报异常时，这三个参数将都为None。 6.6.2 理解并使用 contextlib在上一节中，我们只是为了构建一个上下文管理器，却写了一个类。如果只是要实现一个简单的功能，写一个类未免有点过于繁杂。这时候，我们就想，如果只写一个函数就可以实现上下文管理器就好了。 这个点Python早就想到了。它给我们提供了一个装饰器，你只要按照它的代码协议来实现函数内容，就可以将这个函数对象变成一个上下文管理器。 我们按照 contextlib 的协议来自己实现一个打开文件（with open）的上下文管理器。 在被装饰函数里，必须是一个生成器（带有yield），而yield之前的代码，就相当于__enter__里的内容。yield 之后的代码，就相当于__exit__ 里的内容。 上面这段代码只能实现上下文管理器的第一个目的（管理资源），并不能实现第二个目的（处理异常）。 如果要处理异常，可以改成下面这个样子。 6.6.3 上下文管理器案例需求：给书名自动添加书名号 总结起来，使用上下文管理器有三个好处： 提高代码的复用率； 提高代码的优雅度； 提高代码的可读性； 自己动手：改为contextlib定义上下文管理器的方式 七、前端开发7.1 常用标签 &lt;div&gt;div 标签它是可用于组合其他HTML元素的容器。 可用于对大的内容块设置样式属性。 文档布局。它取代了使用表格定义布局的老式方法。 hx 是HTML的标题 标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题 html提供的标题有六种分别是h1 h2 h3 h4 h5 h6。 &lt;h1&gt;定义字号最大的标题,代表大标题,一般一个页面只用一次。 &lt;h6&gt;定义字号最小的标题。 &lt;p&gt;p 元素定义段落,会自动在其前后创建一些空白。浏览器会自动添加这些空间。 &lt;br&gt;br 元素会在浏览器插入一个简单的换行符。 &lt;hr&gt;hr 标签定义 HTML 页面中的主题变化（比如话题的转移），并显示为一条水平线。 &lt;a&gt;a标签签用来设置超文本链接。 超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。 href属性：描述了链接的目标URL。 target属性：设置链接跳转方式 &lt;img&gt;img 标签用来申明图像的插入。 src属性：规定显示图像的 URL。URL为图片的相对路径或者绝对路径均可。 alt属性：规定图像的替代文本。 title属性：定义图片的标题，鼠标移动到图片出现。 &lt;span&gt;span 用来组合文档中的行内元素,可用作文本的容器。 span 元素没有固定的格式表现，当对它应用样式时，它才会产生视觉上的变化。 &lt;ul&gt;ul 标签作为无序列表，它是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记，无序列表始于&lt;ul&gt;标签。每个列表项始于&lt;li&gt;标签 &lt;ol&gt;有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于&lt;ol&gt;标签。每个列表项始于&lt;li&gt;标签 &lt;!-- 注释 --&gt;注释标签用于在源代码中插入注释。注释不会显示在浏览器中。可使用注释对代码进行解释，这样做有助于在以后的时间对代码的修改，当编写了大量代码时尤其有用 7.2 CSS7.2.1 css选择器通配符选择器：“*”符号是通配符选择器，匹配html中所有元素。 标签选择器：标签选择器为HTML元素指定特定的样式。 类选择器：类选择器可以为标有特定class的HTML元素指定特定的样式。类选择器以“.”来定义。 id选择器：id选择器可以为标有特定id的HTML元素指定特定的样式。id选择器以“#”来定义。 派生选择器：派生选择器允许你根据文档的上下文关系来确定某个标签的样式。 选择器分组：对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。 7.2.2 css常用属性（1）CSS字体 font-size：设置文本大小。 属性值： {number+px}：固定值尺寸像素。 {number+%}：其百分比取值是基于父对象中字体的尺寸大小。 示例： color: 设置文本字体的颜色。 属性值： name：颜色名称指定 color。 rgb：指定颜色为RGB值。 {颜色16进制}：指定颜色为16进制。 示例： text-align：设置文本字体的对齐方式。 属性值： left：默认值，左对齐。 center：居中对齐。 Right：右对齐。 示例： （2）CSS 背景 background-color: 设置对象的背景颜色。 属性值： transparent：默认值(背景色透明)。 {color}：指定颜色。 示例： background-image: 设置对象的背景图像。 属性值： none：默认值(无背景图)。 url({url})：使用绝对或相对 url 地址指定背景图像。 示例： background-repeat: 设置对象的背景图像铺排方式。 属性值： repeat：默认值(背景图像在纵向和横向平铺)。 no-repeat：背景图像不平铺。 repeat-x：背景图像仅在横向平铺。 repeat-y：背景图像仅在纵向平铺。 示例： 7.2.3 盒子模型（1）外边距（margin） 外边距（margin）：就是围绕在元素边框的空白区域，设置外边距会在元素外创建额外的“空白”设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值 属性： margin-top：设置上方外边距。 margin-left：设置左方外边距。 margin-right：设置右方外边距。 margin-bottom：设置下方外边距。 margin外边距简写： {a}：只有一个值的时候，即上下左右外边距都为a值。 {a b}：只有两个值的时候，即上下外边距为a值，左右外边距为b值。 {a b c}：只有三个值的时候，即上外边距为a值，左右外边距为b值，下外边距为c值。 {a b c d}：只有四个值时候，即上外边距为a值，右外边距为b值，下外边距为c值，左外边距为d值（口诀：顺时针，上右下左）。 示例 （2）内边距（padding） 内边距（padding）：就是在边框和内容区之间设置内边距的最简单的方法就是使用 padding 属性，这个属性接受任何长度单位、百分数值。 属性： padding-top：设置上方内边距。 padding-left：设置左方内边距。 padding-right：设置右方内边距。 padding-bottom：设置下方内边距。 padding内边距简写： {a}：只有一个值的时候，即上下左右内边距都为a值。 {a b}：只有两个值的时候，即上下内边距为a值，左右内边距为b值。 {a b c}：只有三个值的时候，即上内边距为a值，左右内边距为b值，下内边距为c值。 {a b c d}：只有四个值时候，即上内边距为a值，右内边距为b值，下内边距为c值，左内边距为d值（口诀：顺时针，上右下左）。 示例： （3）边框（border） 边框（border）：就是围绕元素内容和内边距的一条或多条线，设置边框的最简单的方法就是使用 border 属性，允许规定元素边框的样式、宽度和颜色。请参照图10-9。 属性 border-width：设置边框的宽度。 border-style：设置边框的样式。 none：默认值，无边框。 solid：定义实线边框。 double：定义双实线边框。 dotted：定义点状线边框。 dashed：定义虚线边框。 border-color：设置边框的颜色。 border 边框的简写： {width style color}：定义宽度为width，样式为style，颜色为color的边框。 示例： （4）display属性 display属性：设置元素如何显示。 属性值 inline：默认值。此元素会被显示为内联元素，元素前后没有换行符，内联元素所占具的空间就是他的标签所定义的大小（不能设置width和height）。 inline-block：设置元素为行内块状元素，所有的块级元素开始于新的一行，延展到其容器的宽度（能设置width和height）。 none：设置元素不显示不占空间，元素与其子元素从普通文档流中移除。这时文档的渲染就像元素从来没有存在过一样，也就是说它所占据的空间被折叠了。 block：设置元素为块状元素（能设置width和height）。 table：设置元素为块状表格元素。 inline-table：设置元素为内联表格元素。 示例： 八、网络爬虫8.1 robots协议网站通过该协议告诉爬虫哪些页面可以抓取,哪些页面不能抓取 8.2 urllib库Urllib是Python内置的URL处理模块，提供了一系列用于操作URL的功能。Urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应 8.3 requests库使用requests发送请求获取响应 为了隐藏自己的ip，避免被封，我们可以在爬取数据的时候使用代理 目前各大网站基本有自己的ca证书，但是不排除有的网站为了节约网站建设开销并没有购买ca证书。又因为requests模块在发送网络请求的时候，默认会验证ca证书。如果当前网站没有ca证书，那么就会抛出 SSLError 异常那么我们可以用verify关键字参数，在请求的时候不验证网站的ca证书 8.3 xpathXPath使用路径表达式在XML文档中选取节点。节点是通过路径或者步来选取的 表达式 描述 nodename 选取此节点名的所节点。 &#x2F; 从根节点选取。 &#x2F;&#x2F; 从匹配选择的当前节点是选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 text() 选取文字。 谓语是被嵌在方括号中的部分。在下面的表格所示，我们列出了带有谓语的一些路径表达式，以及表达式的结果。 路径表达式 结果 &#x2F;&#x2F;bookstore&#x2F;book[1] 选取属于bookstore子元素的第一个book元素。 &#x2F;&#x2F;bookstore&#x2F;book[last()] 选取属于bookstore子元素的最后一个book元素。 &#x2F;&#x2F;bookstore&#x2F;book[last()-1] 选取属于bookstore子元素的倒数第二个book元素。 &#x2F;&#x2F;bookstore&#x2F;book[position()&lt;3] 选取最前面的两个属于bookstore元素的子元素的book元素。 &#x2F;&#x2F;title[@lang] 选取所有拥有名为lang的属性的title元素。 &#x2F;&#x2F;title[@lang &#x3D; ‘en’] 选取所有title元素，且这些元素拥有值为en的lang属性。 &#x2F;&#x2F;bookstore&#x2F;book[price&gt;50.00] 选取bookstore元素的所有book元素，且其中的price元素的值须大于50.00。 &#x2F;&#x2F;bookstore&#x2F;book[price&gt;505.00]&#x2F;title 选取bookstore元素中的book元素的所有title元素，且其中的price元素的值须大于50.00。 8.4 Beautiful Soup 4Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库 "},{"title":"Markdown语法","date":"2022-02-12T14:29:34.000Z","url":"/2022/02/12/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","categories":[["undefined",""]],"content":"Markdown标题语法要创建标题，请在单词或短语前面添加井号（#）。#的数量代表了标题的级别。例如，添加三个#表示创建一个三级标题（&lt;h3&gt;）（例如：### My Header） Markdown段落语法要创建段落，请使用空白行将一行或多行文本进行分割。 Markdown换行语法在一行的末尾添加两个或多个空格，然后按回车键，即可创建一个换行（&lt;br&gt;）。 Markdown强调语法通过将文本设置为粗体或斜体来强调其重要性。 粗体（Bold）要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。 粗体（Bold）用法最佳实践Markdown应用程序在如何处理单词或短语的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。 斜体（ltalic）要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。 斜体（ltalic）用法最佳实践要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。 粗体（Bold）和斜体（ltalic）要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。 粗体（Bold）和斜体（ltalic）用法最佳实践Markdown应用程序在处理单词或短语中间添加的下划线上并不一致。为了实践兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。 Markdown引用语法要创建块引用，请在段落前添加一个&gt;符号。 多个段落的块引用块引用可以包含多个段落。为段落之间的空白行添加一个&gt;符号。 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个&gt;&gt;符号。 带有其他元素的块引用块引用可以包含其他Markdown格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。 Markdown列表语法可以将多个条目组织成有序或无序的列表。 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字1起始。 无序列表要创建无序列表，请在每个列表项前面添加破折号（-）、星号（*）、或加号（+）。缩进一个或多个列表项可创建嵌套列表。 Markdown代码语法要将单词或短语表示为代码，请将其包裹在反引号（&#96;）中。 转移反引号如果你要表示为代码的单词或短语中包含一个或多个反应号，则可以通过将单词或短语包裹在双反引号（&#96;）中。 代码块要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。Note:要创建不用缩进的代码块，请使用围栏式代码块（fenced code blocks） Markdown分割线语法要创建分割线，请在单独一行上使用三个或多个星号（***）、破折号（---）或下划线（___），并且不能包含其他内容。 分割线（Horizontal Rule）用法最佳实践为了兼容性，请在分割线的前后均添加空白行。 Markdown链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。超链接Markdown语法代码：[超链接显示名](超链接地址&quot;超链接title&quot;)对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt; 这是一个链接[Markdown语法]()。渲染效果如下：这是一个链接Markdown语法。 给链接增加Title链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。 网址和Email地址使用尖括号可以很方便地把URL或者email地址变成可点击的链接。 带格式化的链接强调链接，在链接语法前后增加星号。要将链接表示为代码，请在方括号中添加反引号。 引用类型链接引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及储存在文件中其他位置的部分，以使文本已于阅读。 链接的第一部分格式引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。 尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。 链接的第二部分格式引用类型链接的第二部分使用以下属性设置格式： 放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。链接的URL，可以选择将其括在尖括号中。链接的可选标题，可以将其括在双引号，单引号或括号中。可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如未注或脚注）。 链接最佳实践不同的Markdown应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。 Markdown图片语法要添加图像，请使用感叹号（!），然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 插入图片Markdown语法代码：![图片alt](图片链接 &quot;图片title&quot;)。对应的HTML代码：&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; titlt=&quot;图片title&quot;&gt; 链接图片给图片增加链接，请将图像的Markdown括在括号中，然后将链接添加在圆括号中。 [![沙漠中的岩石图片](/assets/img/shiprock.jpg &quot;Shiprock&quot;)]() Markdown转义字符语法要显示原本用于格式化Markdown文档的字符，请在字符前面添加反斜杠字符\\。 Markdown内嵌HTML标签对于Markdown涵盖范围之外的标签，都可以直接在文件里面用HTML本身。如需使用HTML，奴需要额外标注这是HTML或是Markdown，只需HTML标签添加到Markdown文本中即可。 行级内联标签HTML 的行级內联标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt;不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的&lt;a&gt;或&lt;img&gt;标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。 HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。 区块标签区块元素——比如&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 &lt;p&gt; 标签。 请注意，Markdown语法在HTML区块标签中将不会被处理。例如：你无法在HTML区块内使用Markdown形式的*强调*。 HTML用法最佳实践出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。如有疑问，请查看相应 Markdown 应用程序的手册。某些应用程序只支持 HTML 标签的子集。 对于 HTML 的块级元素 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt; 和 &lt;p&gt;，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。 在 HTML 块级标签内不能使用 Markdown 语法。例如 &lt;p&gt;italic and **bold**&lt;/p&gt; 将不起作用。"},{"title":"Hello World","date":"2022-02-12T03:23:52.856Z","url":"/2022/02/12/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]